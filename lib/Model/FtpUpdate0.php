<?php
/**
 * FtpUpdate0
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TrueNAS RESTful API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RMoore\Truenas\Model;

use \ArrayAccess;
use \RMoore\Truenas\ObjectSerializer;

/**
 * FtpUpdate0 Class Doc Comment
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class FtpUpdate0 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ftp_update_0';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'port' => 'int',
        'clients' => 'int',
        'ipconnections' => 'int',
        'loginattempt' => 'int',
        'timeout' => 'int',
        'timeout_notransfer' => 'int',
        'rootlogin' => 'bool',
        'onlyanonymous' => 'bool',
        'anonpath' => 'string',
        'onlylocal' => 'bool',
        'banner' => 'string',
        'filemask' => 'string',
        'dirmask' => 'string',
        'fxp' => 'bool',
        'resume' => 'bool',
        'defaultroot' => 'bool',
        'ident' => 'bool',
        'reversedns' => 'bool',
        'masqaddress' => 'string',
        'passiveportsmin' => 'int',
        'passiveportsmax' => 'int',
        'localuserbw' => 'int',
        'localuserdlbw' => 'int',
        'anonuserbw' => 'int',
        'anonuserdlbw' => 'int',
        'tls' => 'bool',
        'tls_policy' => 'string',
        'tls_opt_allow_client_renegotiations' => 'bool',
        'tls_opt_allow_dot_login' => 'bool',
        'tls_opt_allow_per_user' => 'bool',
        'tls_opt_common_name_required' => 'bool',
        'tls_opt_enable_diags' => 'bool',
        'tls_opt_export_cert_data' => 'bool',
        'tls_opt_no_cert_request' => 'bool',
        'tls_opt_no_empty_fragments' => 'bool',
        'tls_opt_no_session_reuse_required' => 'bool',
        'tls_opt_stdenvvars' => 'bool',
        'tls_opt_dns_name_required' => 'bool',
        'tls_opt_ip_address_required' => 'bool',
        'ssltls_certificate' => 'int',
        'options' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'port' => null,
        'clients' => null,
        'ipconnections' => null,
        'loginattempt' => null,
        'timeout' => null,
        'timeout_notransfer' => null,
        'rootlogin' => null,
        'onlyanonymous' => null,
        'anonpath' => null,
        'onlylocal' => null,
        'banner' => null,
        'filemask' => null,
        'dirmask' => null,
        'fxp' => null,
        'resume' => null,
        'defaultroot' => null,
        'ident' => null,
        'reversedns' => null,
        'masqaddress' => null,
        'passiveportsmin' => null,
        'passiveportsmax' => null,
        'localuserbw' => null,
        'localuserdlbw' => null,
        'anonuserbw' => null,
        'anonuserdlbw' => null,
        'tls' => null,
        'tls_policy' => null,
        'tls_opt_allow_client_renegotiations' => null,
        'tls_opt_allow_dot_login' => null,
        'tls_opt_allow_per_user' => null,
        'tls_opt_common_name_required' => null,
        'tls_opt_enable_diags' => null,
        'tls_opt_export_cert_data' => null,
        'tls_opt_no_cert_request' => null,
        'tls_opt_no_empty_fragments' => null,
        'tls_opt_no_session_reuse_required' => null,
        'tls_opt_stdenvvars' => null,
        'tls_opt_dns_name_required' => null,
        'tls_opt_ip_address_required' => null,
        'ssltls_certificate' => null,
        'options' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'port' => false,
		'clients' => false,
		'ipconnections' => false,
		'loginattempt' => false,
		'timeout' => false,
		'timeout_notransfer' => false,
		'rootlogin' => false,
		'onlyanonymous' => false,
		'anonpath' => true,
		'onlylocal' => false,
		'banner' => false,
		'filemask' => false,
		'dirmask' => false,
		'fxp' => false,
		'resume' => false,
		'defaultroot' => false,
		'ident' => false,
		'reversedns' => false,
		'masqaddress' => false,
		'passiveportsmin' => false,
		'passiveportsmax' => false,
		'localuserbw' => false,
		'localuserdlbw' => false,
		'anonuserbw' => false,
		'anonuserdlbw' => false,
		'tls' => false,
		'tls_policy' => false,
		'tls_opt_allow_client_renegotiations' => false,
		'tls_opt_allow_dot_login' => false,
		'tls_opt_allow_per_user' => false,
		'tls_opt_common_name_required' => false,
		'tls_opt_enable_diags' => false,
		'tls_opt_export_cert_data' => false,
		'tls_opt_no_cert_request' => false,
		'tls_opt_no_empty_fragments' => false,
		'tls_opt_no_session_reuse_required' => false,
		'tls_opt_stdenvvars' => false,
		'tls_opt_dns_name_required' => false,
		'tls_opt_ip_address_required' => false,
		'ssltls_certificate' => true,
		'options' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'port' => 'port',
        'clients' => 'clients',
        'ipconnections' => 'ipconnections',
        'loginattempt' => 'loginattempt',
        'timeout' => 'timeout',
        'timeout_notransfer' => 'timeout_notransfer',
        'rootlogin' => 'rootlogin',
        'onlyanonymous' => 'onlyanonymous',
        'anonpath' => 'anonpath',
        'onlylocal' => 'onlylocal',
        'banner' => 'banner',
        'filemask' => 'filemask',
        'dirmask' => 'dirmask',
        'fxp' => 'fxp',
        'resume' => 'resume',
        'defaultroot' => 'defaultroot',
        'ident' => 'ident',
        'reversedns' => 'reversedns',
        'masqaddress' => 'masqaddress',
        'passiveportsmin' => 'passiveportsmin',
        'passiveportsmax' => 'passiveportsmax',
        'localuserbw' => 'localuserbw',
        'localuserdlbw' => 'localuserdlbw',
        'anonuserbw' => 'anonuserbw',
        'anonuserdlbw' => 'anonuserdlbw',
        'tls' => 'tls',
        'tls_policy' => 'tls_policy',
        'tls_opt_allow_client_renegotiations' => 'tls_opt_allow_client_renegotiations',
        'tls_opt_allow_dot_login' => 'tls_opt_allow_dot_login',
        'tls_opt_allow_per_user' => 'tls_opt_allow_per_user',
        'tls_opt_common_name_required' => 'tls_opt_common_name_required',
        'tls_opt_enable_diags' => 'tls_opt_enable_diags',
        'tls_opt_export_cert_data' => 'tls_opt_export_cert_data',
        'tls_opt_no_cert_request' => 'tls_opt_no_cert_request',
        'tls_opt_no_empty_fragments' => 'tls_opt_no_empty_fragments',
        'tls_opt_no_session_reuse_required' => 'tls_opt_no_session_reuse_required',
        'tls_opt_stdenvvars' => 'tls_opt_stdenvvars',
        'tls_opt_dns_name_required' => 'tls_opt_dns_name_required',
        'tls_opt_ip_address_required' => 'tls_opt_ip_address_required',
        'ssltls_certificate' => 'ssltls_certificate',
        'options' => 'options'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'port' => 'setPort',
        'clients' => 'setClients',
        'ipconnections' => 'setIpconnections',
        'loginattempt' => 'setLoginattempt',
        'timeout' => 'setTimeout',
        'timeout_notransfer' => 'setTimeoutNotransfer',
        'rootlogin' => 'setRootlogin',
        'onlyanonymous' => 'setOnlyanonymous',
        'anonpath' => 'setAnonpath',
        'onlylocal' => 'setOnlylocal',
        'banner' => 'setBanner',
        'filemask' => 'setFilemask',
        'dirmask' => 'setDirmask',
        'fxp' => 'setFxp',
        'resume' => 'setResume',
        'defaultroot' => 'setDefaultroot',
        'ident' => 'setIdent',
        'reversedns' => 'setReversedns',
        'masqaddress' => 'setMasqaddress',
        'passiveportsmin' => 'setPassiveportsmin',
        'passiveportsmax' => 'setPassiveportsmax',
        'localuserbw' => 'setLocaluserbw',
        'localuserdlbw' => 'setLocaluserdlbw',
        'anonuserbw' => 'setAnonuserbw',
        'anonuserdlbw' => 'setAnonuserdlbw',
        'tls' => 'setTls',
        'tls_policy' => 'setTlsPolicy',
        'tls_opt_allow_client_renegotiations' => 'setTlsOptAllowClientRenegotiations',
        'tls_opt_allow_dot_login' => 'setTlsOptAllowDotLogin',
        'tls_opt_allow_per_user' => 'setTlsOptAllowPerUser',
        'tls_opt_common_name_required' => 'setTlsOptCommonNameRequired',
        'tls_opt_enable_diags' => 'setTlsOptEnableDiags',
        'tls_opt_export_cert_data' => 'setTlsOptExportCertData',
        'tls_opt_no_cert_request' => 'setTlsOptNoCertRequest',
        'tls_opt_no_empty_fragments' => 'setTlsOptNoEmptyFragments',
        'tls_opt_no_session_reuse_required' => 'setTlsOptNoSessionReuseRequired',
        'tls_opt_stdenvvars' => 'setTlsOptStdenvvars',
        'tls_opt_dns_name_required' => 'setTlsOptDnsNameRequired',
        'tls_opt_ip_address_required' => 'setTlsOptIpAddressRequired',
        'ssltls_certificate' => 'setSsltlsCertificate',
        'options' => 'setOptions'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'port' => 'getPort',
        'clients' => 'getClients',
        'ipconnections' => 'getIpconnections',
        'loginattempt' => 'getLoginattempt',
        'timeout' => 'getTimeout',
        'timeout_notransfer' => 'getTimeoutNotransfer',
        'rootlogin' => 'getRootlogin',
        'onlyanonymous' => 'getOnlyanonymous',
        'anonpath' => 'getAnonpath',
        'onlylocal' => 'getOnlylocal',
        'banner' => 'getBanner',
        'filemask' => 'getFilemask',
        'dirmask' => 'getDirmask',
        'fxp' => 'getFxp',
        'resume' => 'getResume',
        'defaultroot' => 'getDefaultroot',
        'ident' => 'getIdent',
        'reversedns' => 'getReversedns',
        'masqaddress' => 'getMasqaddress',
        'passiveportsmin' => 'getPassiveportsmin',
        'passiveportsmax' => 'getPassiveportsmax',
        'localuserbw' => 'getLocaluserbw',
        'localuserdlbw' => 'getLocaluserdlbw',
        'anonuserbw' => 'getAnonuserbw',
        'anonuserdlbw' => 'getAnonuserdlbw',
        'tls' => 'getTls',
        'tls_policy' => 'getTlsPolicy',
        'tls_opt_allow_client_renegotiations' => 'getTlsOptAllowClientRenegotiations',
        'tls_opt_allow_dot_login' => 'getTlsOptAllowDotLogin',
        'tls_opt_allow_per_user' => 'getTlsOptAllowPerUser',
        'tls_opt_common_name_required' => 'getTlsOptCommonNameRequired',
        'tls_opt_enable_diags' => 'getTlsOptEnableDiags',
        'tls_opt_export_cert_data' => 'getTlsOptExportCertData',
        'tls_opt_no_cert_request' => 'getTlsOptNoCertRequest',
        'tls_opt_no_empty_fragments' => 'getTlsOptNoEmptyFragments',
        'tls_opt_no_session_reuse_required' => 'getTlsOptNoSessionReuseRequired',
        'tls_opt_stdenvvars' => 'getTlsOptStdenvvars',
        'tls_opt_dns_name_required' => 'getTlsOptDnsNameRequired',
        'tls_opt_ip_address_required' => 'getTlsOptIpAddressRequired',
        'ssltls_certificate' => 'getSsltlsCertificate',
        'options' => 'getOptions'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TLS_POLICY_ON = 'on';
    public const TLS_POLICY_OFF = 'off';
    public const TLS_POLICY_DATA = 'data';
    public const TLS_POLICY_DATA = '!data';
    public const TLS_POLICY_AUTH = 'auth';
    public const TLS_POLICY_CTRL = 'ctrl';
    public const TLS_POLICY_CTRLDATA = 'ctrl+data';
    public const TLS_POLICY_CTRLDATA = 'ctrl+!data';
    public const TLS_POLICY_AUTHDATA = 'auth+data';
    public const TLS_POLICY_AUTHDATA = 'auth+!data';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTlsPolicyAllowableValues()
    {
        return [
            self::TLS_POLICY_ON,
            self::TLS_POLICY_OFF,
            self::TLS_POLICY_DATA,
            self::TLS_POLICY_DATA,
            self::TLS_POLICY_AUTH,
            self::TLS_POLICY_CTRL,
            self::TLS_POLICY_CTRLDATA,
            self::TLS_POLICY_CTRLDATA,
            self::TLS_POLICY_AUTHDATA,
            self::TLS_POLICY_AUTHDATA,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('port', $data ?? [], null);
        $this->setIfExists('clients', $data ?? [], null);
        $this->setIfExists('ipconnections', $data ?? [], null);
        $this->setIfExists('loginattempt', $data ?? [], null);
        $this->setIfExists('timeout', $data ?? [], null);
        $this->setIfExists('timeout_notransfer', $data ?? [], null);
        $this->setIfExists('rootlogin', $data ?? [], null);
        $this->setIfExists('onlyanonymous', $data ?? [], null);
        $this->setIfExists('anonpath', $data ?? [], null);
        $this->setIfExists('onlylocal', $data ?? [], null);
        $this->setIfExists('banner', $data ?? [], null);
        $this->setIfExists('filemask', $data ?? [], null);
        $this->setIfExists('dirmask', $data ?? [], null);
        $this->setIfExists('fxp', $data ?? [], null);
        $this->setIfExists('resume', $data ?? [], null);
        $this->setIfExists('defaultroot', $data ?? [], null);
        $this->setIfExists('ident', $data ?? [], null);
        $this->setIfExists('reversedns', $data ?? [], null);
        $this->setIfExists('masqaddress', $data ?? [], null);
        $this->setIfExists('passiveportsmin', $data ?? [], null);
        $this->setIfExists('passiveportsmax', $data ?? [], null);
        $this->setIfExists('localuserbw', $data ?? [], null);
        $this->setIfExists('localuserdlbw', $data ?? [], null);
        $this->setIfExists('anonuserbw', $data ?? [], null);
        $this->setIfExists('anonuserdlbw', $data ?? [], null);
        $this->setIfExists('tls', $data ?? [], null);
        $this->setIfExists('tls_policy', $data ?? [], null);
        $this->setIfExists('tls_opt_allow_client_renegotiations', $data ?? [], null);
        $this->setIfExists('tls_opt_allow_dot_login', $data ?? [], null);
        $this->setIfExists('tls_opt_allow_per_user', $data ?? [], null);
        $this->setIfExists('tls_opt_common_name_required', $data ?? [], null);
        $this->setIfExists('tls_opt_enable_diags', $data ?? [], null);
        $this->setIfExists('tls_opt_export_cert_data', $data ?? [], null);
        $this->setIfExists('tls_opt_no_cert_request', $data ?? [], null);
        $this->setIfExists('tls_opt_no_empty_fragments', $data ?? [], null);
        $this->setIfExists('tls_opt_no_session_reuse_required', $data ?? [], null);
        $this->setIfExists('tls_opt_stdenvvars', $data ?? [], null);
        $this->setIfExists('tls_opt_dns_name_required', $data ?? [], null);
        $this->setIfExists('tls_opt_ip_address_required', $data ?? [], null);
        $this->setIfExists('ssltls_certificate', $data ?? [], null);
        $this->setIfExists('options', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getTlsPolicyAllowableValues();
        if (!is_null($this->container['tls_policy']) && !in_array($this->container['tls_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'tls_policy', must be one of '%s'",
                $this->container['tls_policy'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets port
     *
     * @return int|null
     */
    public function getPort()
    {
        return $this->container['port'];
    }

    /**
     * Sets port
     *
     * @param int|null $port port
     *
     * @return self
     */
    public function setPort($port)
    {

        if (is_null($port)) {
            throw new \InvalidArgumentException('non-nullable port cannot be null');
        }

        $this->container['port'] = $port;

        return $this;
    }

    /**
     * Gets clients
     *
     * @return int|null
     */
    public function getClients()
    {
        return $this->container['clients'];
    }

    /**
     * Sets clients
     *
     * @param int|null $clients `clients` is an integer value which sets the maximum number of simultaneous clients allowed. It defaults to 32.
     *
     * @return self
     */
    public function setClients($clients)
    {

        if (is_null($clients)) {
            throw new \InvalidArgumentException('non-nullable clients cannot be null');
        }

        $this->container['clients'] = $clients;

        return $this;
    }

    /**
     * Gets ipconnections
     *
     * @return int|null
     */
    public function getIpconnections()
    {
        return $this->container['ipconnections'];
    }

    /**
     * Sets ipconnections
     *
     * @param int|null $ipconnections `ipconnections` is an integer value which shows the maximum number of connections per IP address. It defaults to 0 which equals to unlimited.
     *
     * @return self
     */
    public function setIpconnections($ipconnections)
    {

        if (is_null($ipconnections)) {
            throw new \InvalidArgumentException('non-nullable ipconnections cannot be null');
        }

        $this->container['ipconnections'] = $ipconnections;

        return $this;
    }

    /**
     * Gets loginattempt
     *
     * @return int|null
     */
    public function getLoginattempt()
    {
        return $this->container['loginattempt'];
    }

    /**
     * Sets loginattempt
     *
     * @param int|null $loginattempt loginattempt
     *
     * @return self
     */
    public function setLoginattempt($loginattempt)
    {

        if (is_null($loginattempt)) {
            throw new \InvalidArgumentException('non-nullable loginattempt cannot be null');
        }

        $this->container['loginattempt'] = $loginattempt;

        return $this;
    }

    /**
     * Gets timeout
     *
     * @return int|null
     */
    public function getTimeout()
    {
        return $this->container['timeout'];
    }

    /**
     * Sets timeout
     *
     * @param int|null $timeout `timeout` is the maximum number of seconds that proftpd will allow clients to stay connected without receiving any data on either the control or data connection.
     *
     * @return self
     */
    public function setTimeout($timeout)
    {

        if (is_null($timeout)) {
            throw new \InvalidArgumentException('non-nullable timeout cannot be null');
        }

        $this->container['timeout'] = $timeout;

        return $this;
    }

    /**
     * Gets timeout_notransfer
     *
     * @return int|null
     */
    public function getTimeoutNotransfer()
    {
        return $this->container['timeout_notransfer'];
    }

    /**
     * Sets timeout_notransfer
     *
     * @param int|null $timeout_notransfer `timeout_notransfer` is the maximum number of seconds a client is allowed to spend connected, after authentication, without issuing a command which results in creating an active or passive data connection (i.e. sending/receiving a file, or receiving a directory listing).
     *
     * @return self
     */
    public function setTimeoutNotransfer($timeout_notransfer)
    {

        if (is_null($timeout_notransfer)) {
            throw new \InvalidArgumentException('non-nullable timeout_notransfer cannot be null');
        }

        $this->container['timeout_notransfer'] = $timeout_notransfer;

        return $this;
    }

    /**
     * Gets rootlogin
     *
     * @return bool|null
     */
    public function getRootlogin()
    {
        return $this->container['rootlogin'];
    }

    /**
     * Sets rootlogin
     *
     * @param bool|null $rootlogin `rootlogin` is a boolean value which when configured to true enables login as root. This is generally discouraged because of the security risks.
     *
     * @return self
     */
    public function setRootlogin($rootlogin)
    {

        if (is_null($rootlogin)) {
            throw new \InvalidArgumentException('non-nullable rootlogin cannot be null');
        }

        $this->container['rootlogin'] = $rootlogin;

        return $this;
    }

    /**
     * Gets onlyanonymous
     *
     * @return bool|null
     */
    public function getOnlyanonymous()
    {
        return $this->container['onlyanonymous'];
    }

    /**
     * Sets onlyanonymous
     *
     * @param bool|null $onlyanonymous `onlyanonymous` allows anonymous FTP logins with access to the directory specified by `anonpath`.
     *
     * @return self
     */
    public function setOnlyanonymous($onlyanonymous)
    {

        if (is_null($onlyanonymous)) {
            throw new \InvalidArgumentException('non-nullable onlyanonymous cannot be null');
        }

        $this->container['onlyanonymous'] = $onlyanonymous;

        return $this;
    }

    /**
     * Gets anonpath
     *
     * @return string|null
     */
    public function getAnonpath()
    {
        return $this->container['anonpath'];
    }

    /**
     * Sets anonpath
     *
     * @param string|null $anonpath `onlyanonymous` allows anonymous FTP logins with access to the directory specified by `anonpath`.
     *
     * @return self
     */
    public function setAnonpath($anonpath)
    {

        if (is_null($anonpath)) {
            array_push($this->openAPINullablesSetToNull, 'anonpath');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('anonpath', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['anonpath'] = $anonpath;

        return $this;
    }

    /**
     * Gets onlylocal
     *
     * @return bool|null
     */
    public function getOnlylocal()
    {
        return $this->container['onlylocal'];
    }

    /**
     * Sets onlylocal
     *
     * @param bool|null $onlylocal onlylocal
     *
     * @return self
     */
    public function setOnlylocal($onlylocal)
    {

        if (is_null($onlylocal)) {
            throw new \InvalidArgumentException('non-nullable onlylocal cannot be null');
        }

        $this->container['onlylocal'] = $onlylocal;

        return $this;
    }

    /**
     * Gets banner
     *
     * @return string|null
     */
    public function getBanner()
    {
        return $this->container['banner'];
    }

    /**
     * Sets banner
     *
     * @param string|null $banner `banner` is a message displayed to local login users after they successfully authenticate. It is not displayed to anonymous login users.
     *
     * @return self
     */
    public function setBanner($banner)
    {

        if (is_null($banner)) {
            throw new \InvalidArgumentException('non-nullable banner cannot be null');
        }

        $this->container['banner'] = $banner;

        return $this;
    }

    /**
     * Gets filemask
     *
     * @return string|null
     */
    public function getFilemask()
    {
        return $this->container['filemask'];
    }

    /**
     * Sets filemask
     *
     * @param string|null $filemask `filemask` sets the default permissions for newly created files which by default are 077.
     *
     * @return self
     */
    public function setFilemask($filemask)
    {

        if (is_null($filemask)) {
            throw new \InvalidArgumentException('non-nullable filemask cannot be null');
        }

        $this->container['filemask'] = $filemask;

        return $this;
    }

    /**
     * Gets dirmask
     *
     * @return string|null
     */
    public function getDirmask()
    {
        return $this->container['dirmask'];
    }

    /**
     * Sets dirmask
     *
     * @param string|null $dirmask `dirmask` sets the default permissions for newly created directories which by default are 077.
     *
     * @return self
     */
    public function setDirmask($dirmask)
    {

        if (is_null($dirmask)) {
            throw new \InvalidArgumentException('non-nullable dirmask cannot be null');
        }

        $this->container['dirmask'] = $dirmask;

        return $this;
    }

    /**
     * Gets fxp
     *
     * @return bool|null
     */
    public function getFxp()
    {
        return $this->container['fxp'];
    }

    /**
     * Sets fxp
     *
     * @param bool|null $fxp `fxp` if set to true indicates that File eXchange Protocol is enabled. Generally it is discouraged as it makes the server vulnerable to FTP bounce attacks.
     *
     * @return self
     */
    public function setFxp($fxp)
    {

        if (is_null($fxp)) {
            throw new \InvalidArgumentException('non-nullable fxp cannot be null');
        }

        $this->container['fxp'] = $fxp;

        return $this;
    }

    /**
     * Gets resume
     *
     * @return bool|null
     */
    public function getResume()
    {
        return $this->container['resume'];
    }

    /**
     * Sets resume
     *
     * @param bool|null $resume `resume` if set allows FTP clients to resume interrupted transfers.
     *
     * @return self
     */
    public function setResume($resume)
    {

        if (is_null($resume)) {
            throw new \InvalidArgumentException('non-nullable resume cannot be null');
        }

        $this->container['resume'] = $resume;

        return $this;
    }

    /**
     * Gets defaultroot
     *
     * @return bool|null
     */
    public function getDefaultroot()
    {
        return $this->container['defaultroot'];
    }

    /**
     * Sets defaultroot
     *
     * @param bool|null $defaultroot `defaultroot` when set ensures that for local users, home directory access is only granted if the user is a member of group wheel.
     *
     * @return self
     */
    public function setDefaultroot($defaultroot)
    {

        if (is_null($defaultroot)) {
            throw new \InvalidArgumentException('non-nullable defaultroot cannot be null');
        }

        $this->container['defaultroot'] = $defaultroot;

        return $this;
    }

    /**
     * Gets ident
     *
     * @return bool|null
     */
    public function getIdent()
    {
        return $this->container['ident'];
    }

    /**
     * Sets ident
     *
     * @param bool|null $ident `ident` is a boolean value which when set to true indicates that IDENT authentication is required. If identd is not running on the client, this can result in timeouts.
     *
     * @return self
     */
    public function setIdent($ident)
    {

        if (is_null($ident)) {
            throw new \InvalidArgumentException('non-nullable ident cannot be null');
        }

        $this->container['ident'] = $ident;

        return $this;
    }

    /**
     * Gets reversedns
     *
     * @return bool|null
     */
    public function getReversedns()
    {
        return $this->container['reversedns'];
    }

    /**
     * Sets reversedns
     *
     * @param bool|null $reversedns reversedns
     *
     * @return self
     */
    public function setReversedns($reversedns)
    {

        if (is_null($reversedns)) {
            throw new \InvalidArgumentException('non-nullable reversedns cannot be null');
        }

        $this->container['reversedns'] = $reversedns;

        return $this;
    }

    /**
     * Gets masqaddress
     *
     * @return string|null
     */
    public function getMasqaddress()
    {
        return $this->container['masqaddress'];
    }

    /**
     * Sets masqaddress
     *
     * @param string|null $masqaddress `masqaddress` is the public IP address or hostname which is set if FTP clients cannot connect through a NAT device.
     *
     * @return self
     */
    public function setMasqaddress($masqaddress)
    {

        if (is_null($masqaddress)) {
            throw new \InvalidArgumentException('non-nullable masqaddress cannot be null');
        }

        $this->container['masqaddress'] = $masqaddress;

        return $this;
    }

    /**
     * Gets passiveportsmin
     *
     * @return int|null
     */
    public function getPassiveportsmin()
    {
        return $this->container['passiveportsmin'];
    }

    /**
     * Sets passiveportsmin
     *
     * @param int|null $passiveportsmin passiveportsmin
     *
     * @return self
     */
    public function setPassiveportsmin($passiveportsmin)
    {

        if (is_null($passiveportsmin)) {
            throw new \InvalidArgumentException('non-nullable passiveportsmin cannot be null');
        }

        $this->container['passiveportsmin'] = $passiveportsmin;

        return $this;
    }

    /**
     * Gets passiveportsmax
     *
     * @return int|null
     */
    public function getPassiveportsmax()
    {
        return $this->container['passiveportsmax'];
    }

    /**
     * Sets passiveportsmax
     *
     * @param int|null $passiveportsmax passiveportsmax
     *
     * @return self
     */
    public function setPassiveportsmax($passiveportsmax)
    {

        if (is_null($passiveportsmax)) {
            throw new \InvalidArgumentException('non-nullable passiveportsmax cannot be null');
        }

        $this->container['passiveportsmax'] = $passiveportsmax;

        return $this;
    }

    /**
     * Gets localuserbw
     *
     * @return int|null
     */
    public function getLocaluserbw()
    {
        return $this->container['localuserbw'];
    }

    /**
     * Sets localuserbw
     *
     * @param int|null $localuserbw `localuserbw` is a positive integer value which indicates maximum upload bandwidth in KB/s for local user. Default of zero indicates unlimited upload bandwidth ( from the FTP server configuration ).
     *
     * @return self
     */
    public function setLocaluserbw($localuserbw)
    {

        if (is_null($localuserbw)) {
            throw new \InvalidArgumentException('non-nullable localuserbw cannot be null');
        }

        $this->container['localuserbw'] = $localuserbw;

        return $this;
    }

    /**
     * Gets localuserdlbw
     *
     * @return int|null
     */
    public function getLocaluserdlbw()
    {
        return $this->container['localuserdlbw'];
    }

    /**
     * Sets localuserdlbw
     *
     * @param int|null $localuserdlbw `localuserdlbw` is a positive integer value which indicates maximum download bandwidth in KB/s for local user. Default of zero indicates unlimited download bandwidth ( from the FTP server configuration ).
     *
     * @return self
     */
    public function setLocaluserdlbw($localuserdlbw)
    {

        if (is_null($localuserdlbw)) {
            throw new \InvalidArgumentException('non-nullable localuserdlbw cannot be null');
        }

        $this->container['localuserdlbw'] = $localuserdlbw;

        return $this;
    }

    /**
     * Gets anonuserbw
     *
     * @return int|null
     */
    public function getAnonuserbw()
    {
        return $this->container['anonuserbw'];
    }

    /**
     * Sets anonuserbw
     *
     * @param int|null $anonuserbw `anonuserbw` is a positive integer value which indicates maximum upload bandwidth in KB/s for anonymous user. Default of zero indicates unlimited upload bandwidth ( from the FTP server configuration ).
     *
     * @return self
     */
    public function setAnonuserbw($anonuserbw)
    {

        if (is_null($anonuserbw)) {
            throw new \InvalidArgumentException('non-nullable anonuserbw cannot be null');
        }

        $this->container['anonuserbw'] = $anonuserbw;

        return $this;
    }

    /**
     * Gets anonuserdlbw
     *
     * @return int|null
     */
    public function getAnonuserdlbw()
    {
        return $this->container['anonuserdlbw'];
    }

    /**
     * Sets anonuserdlbw
     *
     * @param int|null $anonuserdlbw `anonuserdlbw` is a positive integer value which indicates maximum download bandwidth in KB/s for anonymous user. Default of zero indicates unlimited download bandwidth ( from the FTP server configuration ).
     *
     * @return self
     */
    public function setAnonuserdlbw($anonuserdlbw)
    {

        if (is_null($anonuserdlbw)) {
            throw new \InvalidArgumentException('non-nullable anonuserdlbw cannot be null');
        }

        $this->container['anonuserdlbw'] = $anonuserdlbw;

        return $this;
    }

    /**
     * Gets tls
     *
     * @return bool|null
     */
    public function getTls()
    {
        return $this->container['tls'];
    }

    /**
     * Sets tls
     *
     * @param bool|null $tls `tls` is a boolean value which when set indicates that encrypted connections are enabled. This requires a certificate to be configured first with the certificate service and the id of certificate is passed on in
     *
     * @return self
     */
    public function setTls($tls)
    {

        if (is_null($tls)) {
            throw new \InvalidArgumentException('non-nullable tls cannot be null');
        }

        $this->container['tls'] = $tls;

        return $this;
    }

    /**
     * Gets tls_policy
     *
     * @return string|null
     */
    public function getTlsPolicy()
    {
        return $this->container['tls_policy'];
    }

    /**
     * Sets tls_policy
     *
     * @param string|null $tls_policy `tls_policy` defines whether the control channel, data channel, both channels, or neither channel of an FTP session must occur over SSL/TLS.
     *
     * @return self
     */
    public function setTlsPolicy($tls_policy)
    {
        $allowedValues = $this->getTlsPolicyAllowableValues();
        if (!is_null($tls_policy) && !in_array($tls_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'tls_policy', must be one of '%s'",
                    $tls_policy,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($tls_policy)) {
            throw new \InvalidArgumentException('non-nullable tls_policy cannot be null');
        }

        $this->container['tls_policy'] = $tls_policy;

        return $this;
    }

    /**
     * Gets tls_opt_allow_client_renegotiations
     *
     * @return bool|null
     */
    public function getTlsOptAllowClientRenegotiations()
    {
        return $this->container['tls_opt_allow_client_renegotiations'];
    }

    /**
     * Sets tls_opt_allow_client_renegotiations
     *
     * @param bool|null $tls_opt_allow_client_renegotiations tls_opt_allow_client_renegotiations
     *
     * @return self
     */
    public function setTlsOptAllowClientRenegotiations($tls_opt_allow_client_renegotiations)
    {

        if (is_null($tls_opt_allow_client_renegotiations)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_allow_client_renegotiations cannot be null');
        }

        $this->container['tls_opt_allow_client_renegotiations'] = $tls_opt_allow_client_renegotiations;

        return $this;
    }

    /**
     * Gets tls_opt_allow_dot_login
     *
     * @return bool|null
     */
    public function getTlsOptAllowDotLogin()
    {
        return $this->container['tls_opt_allow_dot_login'];
    }

    /**
     * Sets tls_opt_allow_dot_login
     *
     * @param bool|null $tls_opt_allow_dot_login tls_opt_allow_dot_login
     *
     * @return self
     */
    public function setTlsOptAllowDotLogin($tls_opt_allow_dot_login)
    {

        if (is_null($tls_opt_allow_dot_login)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_allow_dot_login cannot be null');
        }

        $this->container['tls_opt_allow_dot_login'] = $tls_opt_allow_dot_login;

        return $this;
    }

    /**
     * Gets tls_opt_allow_per_user
     *
     * @return bool|null
     */
    public function getTlsOptAllowPerUser()
    {
        return $this->container['tls_opt_allow_per_user'];
    }

    /**
     * Sets tls_opt_allow_per_user
     *
     * @param bool|null $tls_opt_allow_per_user tls_opt_allow_per_user
     *
     * @return self
     */
    public function setTlsOptAllowPerUser($tls_opt_allow_per_user)
    {

        if (is_null($tls_opt_allow_per_user)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_allow_per_user cannot be null');
        }

        $this->container['tls_opt_allow_per_user'] = $tls_opt_allow_per_user;

        return $this;
    }

    /**
     * Gets tls_opt_common_name_required
     *
     * @return bool|null
     */
    public function getTlsOptCommonNameRequired()
    {
        return $this->container['tls_opt_common_name_required'];
    }

    /**
     * Sets tls_opt_common_name_required
     *
     * @param bool|null $tls_opt_common_name_required tls_opt_common_name_required
     *
     * @return self
     */
    public function setTlsOptCommonNameRequired($tls_opt_common_name_required)
    {

        if (is_null($tls_opt_common_name_required)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_common_name_required cannot be null');
        }

        $this->container['tls_opt_common_name_required'] = $tls_opt_common_name_required;

        return $this;
    }

    /**
     * Gets tls_opt_enable_diags
     *
     * @return bool|null
     */
    public function getTlsOptEnableDiags()
    {
        return $this->container['tls_opt_enable_diags'];
    }

    /**
     * Sets tls_opt_enable_diags
     *
     * @param bool|null $tls_opt_enable_diags `tls_opt_enable_diags` is a boolean value when set, logs verbosely. This is helpful when troubleshooting a connection.
     *
     * @return self
     */
    public function setTlsOptEnableDiags($tls_opt_enable_diags)
    {

        if (is_null($tls_opt_enable_diags)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_enable_diags cannot be null');
        }

        $this->container['tls_opt_enable_diags'] = $tls_opt_enable_diags;

        return $this;
    }

    /**
     * Gets tls_opt_export_cert_data
     *
     * @return bool|null
     */
    public function getTlsOptExportCertData()
    {
        return $this->container['tls_opt_export_cert_data'];
    }

    /**
     * Sets tls_opt_export_cert_data
     *
     * @param bool|null $tls_opt_export_cert_data tls_opt_export_cert_data
     *
     * @return self
     */
    public function setTlsOptExportCertData($tls_opt_export_cert_data)
    {

        if (is_null($tls_opt_export_cert_data)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_export_cert_data cannot be null');
        }

        $this->container['tls_opt_export_cert_data'] = $tls_opt_export_cert_data;

        return $this;
    }

    /**
     * Gets tls_opt_no_cert_request
     *
     * @return bool|null
     */
    public function getTlsOptNoCertRequest()
    {
        return $this->container['tls_opt_no_cert_request'];
    }

    /**
     * Sets tls_opt_no_cert_request
     *
     * @param bool|null $tls_opt_no_cert_request tls_opt_no_cert_request
     *
     * @return self
     */
    public function setTlsOptNoCertRequest($tls_opt_no_cert_request)
    {

        if (is_null($tls_opt_no_cert_request)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_no_cert_request cannot be null');
        }

        $this->container['tls_opt_no_cert_request'] = $tls_opt_no_cert_request;

        return $this;
    }

    /**
     * Gets tls_opt_no_empty_fragments
     *
     * @return bool|null
     */
    public function getTlsOptNoEmptyFragments()
    {
        return $this->container['tls_opt_no_empty_fragments'];
    }

    /**
     * Sets tls_opt_no_empty_fragments
     *
     * @param bool|null $tls_opt_no_empty_fragments tls_opt_no_empty_fragments
     *
     * @return self
     */
    public function setTlsOptNoEmptyFragments($tls_opt_no_empty_fragments)
    {

        if (is_null($tls_opt_no_empty_fragments)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_no_empty_fragments cannot be null');
        }

        $this->container['tls_opt_no_empty_fragments'] = $tls_opt_no_empty_fragments;

        return $this;
    }

    /**
     * Gets tls_opt_no_session_reuse_required
     *
     * @return bool|null
     */
    public function getTlsOptNoSessionReuseRequired()
    {
        return $this->container['tls_opt_no_session_reuse_required'];
    }

    /**
     * Sets tls_opt_no_session_reuse_required
     *
     * @param bool|null $tls_opt_no_session_reuse_required tls_opt_no_session_reuse_required
     *
     * @return self
     */
    public function setTlsOptNoSessionReuseRequired($tls_opt_no_session_reuse_required)
    {

        if (is_null($tls_opt_no_session_reuse_required)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_no_session_reuse_required cannot be null');
        }

        $this->container['tls_opt_no_session_reuse_required'] = $tls_opt_no_session_reuse_required;

        return $this;
    }

    /**
     * Gets tls_opt_stdenvvars
     *
     * @return bool|null
     */
    public function getTlsOptStdenvvars()
    {
        return $this->container['tls_opt_stdenvvars'];
    }

    /**
     * Sets tls_opt_stdenvvars
     *
     * @param bool|null $tls_opt_stdenvvars tls_opt_stdenvvars
     *
     * @return self
     */
    public function setTlsOptStdenvvars($tls_opt_stdenvvars)
    {

        if (is_null($tls_opt_stdenvvars)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_stdenvvars cannot be null');
        }

        $this->container['tls_opt_stdenvvars'] = $tls_opt_stdenvvars;

        return $this;
    }

    /**
     * Gets tls_opt_dns_name_required
     *
     * @return bool|null
     */
    public function getTlsOptDnsNameRequired()
    {
        return $this->container['tls_opt_dns_name_required'];
    }

    /**
     * Sets tls_opt_dns_name_required
     *
     * @param bool|null $tls_opt_dns_name_required tls_opt_dns_name_required
     *
     * @return self
     */
    public function setTlsOptDnsNameRequired($tls_opt_dns_name_required)
    {

        if (is_null($tls_opt_dns_name_required)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_dns_name_required cannot be null');
        }

        $this->container['tls_opt_dns_name_required'] = $tls_opt_dns_name_required;

        return $this;
    }

    /**
     * Gets tls_opt_ip_address_required
     *
     * @return bool|null
     */
    public function getTlsOptIpAddressRequired()
    {
        return $this->container['tls_opt_ip_address_required'];
    }

    /**
     * Sets tls_opt_ip_address_required
     *
     * @param bool|null $tls_opt_ip_address_required tls_opt_ip_address_required
     *
     * @return self
     */
    public function setTlsOptIpAddressRequired($tls_opt_ip_address_required)
    {

        if (is_null($tls_opt_ip_address_required)) {
            throw new \InvalidArgumentException('non-nullable tls_opt_ip_address_required cannot be null');
        }

        $this->container['tls_opt_ip_address_required'] = $tls_opt_ip_address_required;

        return $this;
    }

    /**
     * Gets ssltls_certificate
     *
     * @return int|null
     */
    public function getSsltlsCertificate()
    {
        return $this->container['ssltls_certificate'];
    }

    /**
     * Sets ssltls_certificate
     *
     * @param int|null $ssltls_certificate `ssltls_certificate`.
     *
     * @return self
     */
    public function setSsltlsCertificate($ssltls_certificate)
    {

        if (is_null($ssltls_certificate)) {
            array_push($this->openAPINullablesSetToNull, 'ssltls_certificate');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('ssltls_certificate', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['ssltls_certificate'] = $ssltls_certificate;

        return $this;
    }

    /**
     * Gets options
     *
     * @return string|null
     */
    public function getOptions()
    {
        return $this->container['options'];
    }

    /**
     * Sets options
     *
     * @param string|null $options options
     *
     * @return self
     */
    public function setOptions($options)
    {

        if (is_null($options)) {
            throw new \InvalidArgumentException('non-nullable options cannot be null');
        }

        $this->container['options'] = $options;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


