<?php
/**
 * LdapUpdate0
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TrueNAS RESTful API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RMoore\Truenas\Model;

use \ArrayAccess;
use \RMoore\Truenas\ObjectSerializer;

/**
 * LdapUpdate0 Class Doc Comment
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class LdapUpdate0 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ldap_update_0';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'hostname' => 'mixed[]',
        'basedn' => 'string',
        'binddn' => 'string',
        'bindpw' => 'string',
        'anonbind' => 'bool',
        'ssl' => 'string',
        'certificate' => 'int',
        'validate_certificates' => 'bool',
        'disable_freenas_cache' => 'bool',
        'timeout' => 'int',
        'dns_timeout' => 'int',
        'kerberos_realm' => 'int',
        'kerberos_principal' => 'string',
        'has_samba_schema' => 'bool',
        'auxiliary_parameters' => 'string',
        'schema' => 'string',
        'enable' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'hostname' => null,
        'basedn' => null,
        'binddn' => null,
        'bindpw' => null,
        'anonbind' => null,
        'ssl' => null,
        'certificate' => null,
        'validate_certificates' => null,
        'disable_freenas_cache' => null,
        'timeout' => null,
        'dns_timeout' => null,
        'kerberos_realm' => null,
        'kerberos_principal' => null,
        'has_samba_schema' => null,
        'auxiliary_parameters' => null,
        'schema' => null,
        'enable' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'hostname' => false,
		'basedn' => false,
		'binddn' => false,
		'bindpw' => false,
		'anonbind' => false,
		'ssl' => false,
		'certificate' => true,
		'validate_certificates' => false,
		'disable_freenas_cache' => false,
		'timeout' => false,
		'dns_timeout' => false,
		'kerberos_realm' => true,
		'kerberos_principal' => false,
		'has_samba_schema' => false,
		'auxiliary_parameters' => false,
		'schema' => false,
		'enable' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'hostname' => 'hostname',
        'basedn' => 'basedn',
        'binddn' => 'binddn',
        'bindpw' => 'bindpw',
        'anonbind' => 'anonbind',
        'ssl' => 'ssl',
        'certificate' => 'certificate',
        'validate_certificates' => 'validate_certificates',
        'disable_freenas_cache' => 'disable_freenas_cache',
        'timeout' => 'timeout',
        'dns_timeout' => 'dns_timeout',
        'kerberos_realm' => 'kerberos_realm',
        'kerberos_principal' => 'kerberos_principal',
        'has_samba_schema' => 'has_samba_schema',
        'auxiliary_parameters' => 'auxiliary_parameters',
        'schema' => 'schema',
        'enable' => 'enable'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'hostname' => 'setHostname',
        'basedn' => 'setBasedn',
        'binddn' => 'setBinddn',
        'bindpw' => 'setBindpw',
        'anonbind' => 'setAnonbind',
        'ssl' => 'setSsl',
        'certificate' => 'setCertificate',
        'validate_certificates' => 'setValidateCertificates',
        'disable_freenas_cache' => 'setDisableFreenasCache',
        'timeout' => 'setTimeout',
        'dns_timeout' => 'setDnsTimeout',
        'kerberos_realm' => 'setKerberosRealm',
        'kerberos_principal' => 'setKerberosPrincipal',
        'has_samba_schema' => 'setHasSambaSchema',
        'auxiliary_parameters' => 'setAuxiliaryParameters',
        'schema' => 'setSchema',
        'enable' => 'setEnable'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'hostname' => 'getHostname',
        'basedn' => 'getBasedn',
        'binddn' => 'getBinddn',
        'bindpw' => 'getBindpw',
        'anonbind' => 'getAnonbind',
        'ssl' => 'getSsl',
        'certificate' => 'getCertificate',
        'validate_certificates' => 'getValidateCertificates',
        'disable_freenas_cache' => 'getDisableFreenasCache',
        'timeout' => 'getTimeout',
        'dns_timeout' => 'getDnsTimeout',
        'kerberos_realm' => 'getKerberosRealm',
        'kerberos_principal' => 'getKerberosPrincipal',
        'has_samba_schema' => 'getHasSambaSchema',
        'auxiliary_parameters' => 'getAuxiliaryParameters',
        'schema' => 'getSchema',
        'enable' => 'getEnable'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SSL_OFF = 'OFF';
    public const SSL_ON = 'ON';
    public const SSL_START_TLS = 'START_TLS';
    public const SCHEMA_RFC2307 = 'RFC2307';
    public const SCHEMA_RFC2307_BIS = 'RFC2307BIS';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSslAllowableValues()
    {
        return [
            self::SSL_OFF,
            self::SSL_ON,
            self::SSL_START_TLS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSchemaAllowableValues()
    {
        return [
            self::SCHEMA_RFC2307,
            self::SCHEMA_RFC2307_BIS,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('hostname', $data ?? [], null);
        $this->setIfExists('basedn', $data ?? [], null);
        $this->setIfExists('binddn', $data ?? [], null);
        $this->setIfExists('bindpw', $data ?? [], null);
        $this->setIfExists('anonbind', $data ?? [], false);
        $this->setIfExists('ssl', $data ?? [], 'ON');
        $this->setIfExists('certificate', $data ?? [], null);
        $this->setIfExists('validate_certificates', $data ?? [], true);
        $this->setIfExists('disable_freenas_cache', $data ?? [], null);
        $this->setIfExists('timeout', $data ?? [], 30);
        $this->setIfExists('dns_timeout', $data ?? [], 5);
        $this->setIfExists('kerberos_realm', $data ?? [], null);
        $this->setIfExists('kerberos_principal', $data ?? [], null);
        $this->setIfExists('has_samba_schema', $data ?? [], false);
        $this->setIfExists('auxiliary_parameters', $data ?? [], 'false');
        $this->setIfExists('schema', $data ?? [], 'RFC2307');
        $this->setIfExists('enable', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getSslAllowableValues();
        if (!is_null($this->container['ssl']) && !in_array($this->container['ssl'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ssl', must be one of '%s'",
                $this->container['ssl'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSchemaAllowableValues();
        if (!is_null($this->container['schema']) && !in_array($this->container['schema'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'schema', must be one of '%s'",
                $this->container['schema'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets hostname
     *
     * @return mixed[]|null
     */
    public function getHostname()
    {
        return $this->container['hostname'];
    }

    /**
     * Sets hostname
     *
     * @param mixed[]|null $hostname `hostname` list of ip addresses or hostnames of LDAP servers with which to communicate in order of preference. Failover only occurs if the current LDAP server is unresponsive.
     *
     * @return self
     */
    public function setHostname($hostname)
    {

        if (is_null($hostname)) {
            throw new \InvalidArgumentException('non-nullable hostname cannot be null');
        }

        $this->container['hostname'] = $hostname;

        return $this;
    }

    /**
     * Gets basedn
     *
     * @return string|null
     */
    public function getBasedn()
    {
        return $this->container['basedn'];
    }

    /**
     * Sets basedn
     *
     * @param string|null $basedn `basedn` specifies the default base DN to use when performing ldap operations. The base must be specified as a Distinguished Name in LDAP format.
     *
     * @return self
     */
    public function setBasedn($basedn)
    {

        if (is_null($basedn)) {
            throw new \InvalidArgumentException('non-nullable basedn cannot be null');
        }

        $this->container['basedn'] = $basedn;

        return $this;
    }

    /**
     * Gets binddn
     *
     * @return string|null
     */
    public function getBinddn()
    {
        return $this->container['binddn'];
    }

    /**
     * Sets binddn
     *
     * @param string|null $binddn `binddn` specifies the default bind DN to use when performing ldap operations. The bind DN must be specified as a Distinguished Name in LDAP format. `kerberos_principal` kerberos principal to use for SASL GSSAPI authentication to the remote server. If `kerberos_realm` is specified without a keytab, then the `binddn` and `bindpw` are used to perform to obtain the ticket necessary for GSSAPI authentication.
     *
     * @return self
     */
    public function setBinddn($binddn)
    {

        if (is_null($binddn)) {
            throw new \InvalidArgumentException('non-nullable binddn cannot be null');
        }

        $this->container['binddn'] = $binddn;

        return $this;
    }

    /**
     * Gets bindpw
     *
     * @return string|null
     */
    public function getBindpw()
    {
        return $this->container['bindpw'];
    }

    /**
     * Sets bindpw
     *
     * @param string|null $bindpw `kerberos_principal` kerberos principal to use for SASL GSSAPI authentication to the remote server. If `kerberos_realm` is specified without a keytab, then the `binddn` and `bindpw` are used to perform to obtain the ticket necessary for GSSAPI authentication.
     *
     * @return self
     */
    public function setBindpw($bindpw)
    {

        if (is_null($bindpw)) {
            throw new \InvalidArgumentException('non-nullable bindpw cannot be null');
        }

        $this->container['bindpw'] = $bindpw;

        return $this;
    }

    /**
     * Gets anonbind
     *
     * @return bool|null
     */
    public function getAnonbind()
    {
        return $this->container['anonbind'];
    }

    /**
     * Sets anonbind
     *
     * @param bool|null $anonbind `anonbind` use anonymous authentication.
     *
     * @return self
     */
    public function setAnonbind($anonbind)
    {

        if (is_null($anonbind)) {
            throw new \InvalidArgumentException('non-nullable anonbind cannot be null');
        }

        $this->container['anonbind'] = $anonbind;

        return $this;
    }

    /**
     * Gets ssl
     *
     * @return string|null
     */
    public function getSsl()
    {
        return $this->container['ssl'];
    }

    /**
     * Sets ssl
     *
     * @param string|null $ssl `ssl` establish SSL/TLS-protected connections to the LDAP server(s). GSSAPI signing is disabled on SSL/TLS-protected connections if kerberos authentication is used.
     *
     * @return self
     */
    public function setSsl($ssl)
    {
        $allowedValues = $this->getSslAllowableValues();
        if (!is_null($ssl) && !in_array($ssl, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ssl', must be one of '%s'",
                    $ssl,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($ssl)) {
            throw new \InvalidArgumentException('non-nullable ssl cannot be null');
        }

        $this->container['ssl'] = $ssl;

        return $this;
    }

    /**
     * Gets certificate
     *
     * @return int|null
     */
    public function getCertificate()
    {
        return $this->container['certificate'];
    }

    /**
     * Sets certificate
     *
     * @param int|null $certificate `certificate` LDAPs client certificate to be used for certificate- based authentication.
     *
     * @return self
     */
    public function setCertificate($certificate)
    {

        if (is_null($certificate)) {
            array_push($this->openAPINullablesSetToNull, 'certificate');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('certificate', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['certificate'] = $certificate;

        return $this;
    }

    /**
     * Gets validate_certificates
     *
     * @return bool|null
     */
    public function getValidateCertificates()
    {
        return $this->container['validate_certificates'];
    }

    /**
     * Sets validate_certificates
     *
     * @param bool|null $validate_certificates `validate_certificates` specifies whether to perform checks on server certificates in a TLS session. If enabled, TLS_REQCERT demand is set. The server certificate is requested. If no certificate is provided or if a bad certificate is provided, the session is immediately terminated. If disabled, TLS_REQCERT allow is set. The server certificate is requested, but all errors are ignored.
     *
     * @return self
     */
    public function setValidateCertificates($validate_certificates)
    {

        if (is_null($validate_certificates)) {
            throw new \InvalidArgumentException('non-nullable validate_certificates cannot be null');
        }

        $this->container['validate_certificates'] = $validate_certificates;

        return $this;
    }

    /**
     * Gets disable_freenas_cache
     *
     * @return bool|null
     */
    public function getDisableFreenasCache()
    {
        return $this->container['disable_freenas_cache'];
    }

    /**
     * Sets disable_freenas_cache
     *
     * @param bool|null $disable_freenas_cache disable_freenas_cache
     *
     * @return self
     */
    public function setDisableFreenasCache($disable_freenas_cache)
    {

        if (is_null($disable_freenas_cache)) {
            throw new \InvalidArgumentException('non-nullable disable_freenas_cache cannot be null');
        }

        $this->container['disable_freenas_cache'] = $disable_freenas_cache;

        return $this;
    }

    /**
     * Gets timeout
     *
     * @return int|null
     */
    public function getTimeout()
    {
        return $this->container['timeout'];
    }

    /**
     * Sets timeout
     *
     * @param int|null $timeout `timeout` specifies  a  timeout  (in  seconds) after which calls to synchronous LDAP APIs will abort if no response is received.
     *
     * @return self
     */
    public function setTimeout($timeout)
    {

        if (is_null($timeout)) {
            throw new \InvalidArgumentException('non-nullable timeout cannot be null');
        }

        $this->container['timeout'] = $timeout;

        return $this;
    }

    /**
     * Gets dns_timeout
     *
     * @return int|null
     */
    public function getDnsTimeout()
    {
        return $this->container['dns_timeout'];
    }

    /**
     * Sets dns_timeout
     *
     * @param int|null $dns_timeout `dns_timeout` specifies the timeout (in seconds) after which the poll(2)/select(2) following a connect(2) returns in case of no activity for openldap. For nslcd this specifies the time limit (in seconds) to use when connecting to the directory server. This directly impacts the length of time that the LDAP service tries before failing over to a secondary LDAP URI.
     *
     * @return self
     */
    public function setDnsTimeout($dns_timeout)
    {

        if (is_null($dns_timeout)) {
            throw new \InvalidArgumentException('non-nullable dns_timeout cannot be null');
        }

        $this->container['dns_timeout'] = $dns_timeout;

        return $this;
    }

    /**
     * Gets kerberos_realm
     *
     * @return int|null
     */
    public function getKerberosRealm()
    {
        return $this->container['kerberos_realm'];
    }

    /**
     * Sets kerberos_realm
     *
     * @param int|null $kerberos_realm `kerberos_realm` in which the server is located. This parameter is only required for SASL GSSAPI authentication to the remote LDAP server. `kerberos_principal` kerberos principal to use for SASL GSSAPI authentication to the remote server. If `kerberos_realm` is specified without a keytab, then the `binddn` and `bindpw` are used to perform to obtain the ticket necessary for GSSAPI authentication.
     *
     * @return self
     */
    public function setKerberosRealm($kerberos_realm)
    {

        if (is_null($kerberos_realm)) {
            array_push($this->openAPINullablesSetToNull, 'kerberos_realm');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('kerberos_realm', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['kerberos_realm'] = $kerberos_realm;

        return $this;
    }

    /**
     * Gets kerberos_principal
     *
     * @return string|null
     */
    public function getKerberosPrincipal()
    {
        return $this->container['kerberos_principal'];
    }

    /**
     * Sets kerberos_principal
     *
     * @param string|null $kerberos_principal `kerberos_principal` kerberos principal to use for SASL GSSAPI authentication to the remote server. If `kerberos_realm` is specified without a keytab, then the `binddn` and `bindpw` are used to perform to obtain the ticket necessary for GSSAPI authentication.
     *
     * @return self
     */
    public function setKerberosPrincipal($kerberos_principal)
    {

        if (is_null($kerberos_principal)) {
            throw new \InvalidArgumentException('non-nullable kerberos_principal cannot be null');
        }

        $this->container['kerberos_principal'] = $kerberos_principal;

        return $this;
    }

    /**
     * Gets has_samba_schema
     *
     * @return bool|null
     */
    public function getHasSambaSchema()
    {
        return $this->container['has_samba_schema'];
    }

    /**
     * Sets has_samba_schema
     *
     * @param bool|null $has_samba_schema has_samba_schema
     *
     * @return self
     */
    public function setHasSambaSchema($has_samba_schema)
    {

        if (is_null($has_samba_schema)) {
            throw new \InvalidArgumentException('non-nullable has_samba_schema cannot be null');
        }

        $this->container['has_samba_schema'] = $has_samba_schema;

        return $this;
    }

    /**
     * Gets auxiliary_parameters
     *
     * @return string|null
     */
    public function getAuxiliaryParameters()
    {
        return $this->container['auxiliary_parameters'];
    }

    /**
     * Sets auxiliary_parameters
     *
     * @param string|null $auxiliary_parameters auxiliary_parameters
     *
     * @return self
     */
    public function setAuxiliaryParameters($auxiliary_parameters)
    {

        if (is_null($auxiliary_parameters)) {
            throw new \InvalidArgumentException('non-nullable auxiliary_parameters cannot be null');
        }

        $this->container['auxiliary_parameters'] = $auxiliary_parameters;

        return $this;
    }

    /**
     * Gets schema
     *
     * @return string|null
     */
    public function getSchema()
    {
        return $this->container['schema'];
    }

    /**
     * Sets schema
     *
     * @param string|null $schema schema
     *
     * @return self
     */
    public function setSchema($schema)
    {
        $allowedValues = $this->getSchemaAllowableValues();
        if (!is_null($schema) && !in_array($schema, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'schema', must be one of '%s'",
                    $schema,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($schema)) {
            throw new \InvalidArgumentException('non-nullable schema cannot be null');
        }

        $this->container['schema'] = $schema;

        return $this;
    }

    /**
     * Gets enable
     *
     * @return bool|null
     */
    public function getEnable()
    {
        return $this->container['enable'];
    }

    /**
     * Sets enable
     *
     * @param bool|null $enable enable
     *
     * @return self
     */
    public function setEnable($enable)
    {

        if (is_null($enable)) {
            throw new \InvalidArgumentException('non-nullable enable cannot be null');
        }

        $this->container['enable'] = $enable;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


