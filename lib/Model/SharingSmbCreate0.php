<?php
/**
 * SharingSmbCreate0
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TrueNAS RESTful API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RMoore\Truenas\Model;

use \ArrayAccess;
use \RMoore\Truenas\ObjectSerializer;

/**
 * SharingSmbCreate0 Class Doc Comment
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SharingSmbCreate0 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'sharing_smb_create_0';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'purpose' => 'string',
        'path' => 'string',
        'path_suffix' => 'string',
        'home' => 'bool',
        'name' => 'string',
        'comment' => 'string',
        'ro' => 'bool',
        'browsable' => 'bool',
        'timemachine' => 'bool',
        'timemachine_quota' => 'int',
        'recyclebin' => 'bool',
        'guestok' => 'bool',
        'abe' => 'bool',
        'hostsallow' => 'mixed[]',
        'hostsdeny' => 'mixed[]',
        'aapl_name_mangling' => 'bool',
        'acl' => 'bool',
        'durablehandle' => 'bool',
        'shadowcopy' => 'bool',
        'streams' => 'bool',
        'fsrvp' => 'bool',
        'auxsmbconf' => 'string',
        'enabled' => 'bool',
        'cluster_volname' => 'string',
        'afp' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'purpose' => null,
        'path' => null,
        'path_suffix' => null,
        'home' => null,
        'name' => null,
        'comment' => null,
        'ro' => null,
        'browsable' => null,
        'timemachine' => null,
        'timemachine_quota' => null,
        'recyclebin' => null,
        'guestok' => null,
        'abe' => null,
        'hostsallow' => null,
        'hostsdeny' => null,
        'aapl_name_mangling' => null,
        'acl' => null,
        'durablehandle' => null,
        'shadowcopy' => null,
        'streams' => null,
        'fsrvp' => null,
        'auxsmbconf' => null,
        'enabled' => null,
        'cluster_volname' => null,
        'afp' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'purpose' => false,
		'path' => false,
		'path_suffix' => false,
		'home' => false,
		'name' => false,
		'comment' => false,
		'ro' => false,
		'browsable' => false,
		'timemachine' => false,
		'timemachine_quota' => false,
		'recyclebin' => false,
		'guestok' => false,
		'abe' => false,
		'hostsallow' => false,
		'hostsdeny' => false,
		'aapl_name_mangling' => false,
		'acl' => false,
		'durablehandle' => false,
		'shadowcopy' => false,
		'streams' => false,
		'fsrvp' => false,
		'auxsmbconf' => false,
		'enabled' => false,
		'cluster_volname' => false,
		'afp' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'purpose' => 'purpose',
        'path' => 'path',
        'path_suffix' => 'path_suffix',
        'home' => 'home',
        'name' => 'name',
        'comment' => 'comment',
        'ro' => 'ro',
        'browsable' => 'browsable',
        'timemachine' => 'timemachine',
        'timemachine_quota' => 'timemachine_quota',
        'recyclebin' => 'recyclebin',
        'guestok' => 'guestok',
        'abe' => 'abe',
        'hostsallow' => 'hostsallow',
        'hostsdeny' => 'hostsdeny',
        'aapl_name_mangling' => 'aapl_name_mangling',
        'acl' => 'acl',
        'durablehandle' => 'durablehandle',
        'shadowcopy' => 'shadowcopy',
        'streams' => 'streams',
        'fsrvp' => 'fsrvp',
        'auxsmbconf' => 'auxsmbconf',
        'enabled' => 'enabled',
        'cluster_volname' => 'cluster_volname',
        'afp' => 'afp'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'purpose' => 'setPurpose',
        'path' => 'setPath',
        'path_suffix' => 'setPathSuffix',
        'home' => 'setHome',
        'name' => 'setName',
        'comment' => 'setComment',
        'ro' => 'setRo',
        'browsable' => 'setBrowsable',
        'timemachine' => 'setTimemachine',
        'timemachine_quota' => 'setTimemachineQuota',
        'recyclebin' => 'setRecyclebin',
        'guestok' => 'setGuestok',
        'abe' => 'setAbe',
        'hostsallow' => 'setHostsallow',
        'hostsdeny' => 'setHostsdeny',
        'aapl_name_mangling' => 'setAaplNameMangling',
        'acl' => 'setAcl',
        'durablehandle' => 'setDurablehandle',
        'shadowcopy' => 'setShadowcopy',
        'streams' => 'setStreams',
        'fsrvp' => 'setFsrvp',
        'auxsmbconf' => 'setAuxsmbconf',
        'enabled' => 'setEnabled',
        'cluster_volname' => 'setClusterVolname',
        'afp' => 'setAfp'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'purpose' => 'getPurpose',
        'path' => 'getPath',
        'path_suffix' => 'getPathSuffix',
        'home' => 'getHome',
        'name' => 'getName',
        'comment' => 'getComment',
        'ro' => 'getRo',
        'browsable' => 'getBrowsable',
        'timemachine' => 'getTimemachine',
        'timemachine_quota' => 'getTimemachineQuota',
        'recyclebin' => 'getRecyclebin',
        'guestok' => 'getGuestok',
        'abe' => 'getAbe',
        'hostsallow' => 'getHostsallow',
        'hostsdeny' => 'getHostsdeny',
        'aapl_name_mangling' => 'getAaplNameMangling',
        'acl' => 'getAcl',
        'durablehandle' => 'getDurablehandle',
        'shadowcopy' => 'getShadowcopy',
        'streams' => 'getStreams',
        'fsrvp' => 'getFsrvp',
        'auxsmbconf' => 'getAuxsmbconf',
        'enabled' => 'getEnabled',
        'cluster_volname' => 'getClusterVolname',
        'afp' => 'getAfp'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const PURPOSE_NO_PRESET = 'NO_PRESET';
    public const PURPOSE_DEFAULT_CLUSTER_SHARE = 'DEFAULT_CLUSTER_SHARE';
    public const PURPOSE_DEFAULT_SHARE = 'DEFAULT_SHARE';
    public const PURPOSE_ENHANCED_TIMEMACHINE = 'ENHANCED_TIMEMACHINE';
    public const PURPOSE_MULTI_PROTOCOL_NFS = 'MULTI_PROTOCOL_NFS';
    public const PURPOSE_PRIVATE_DATASETS = 'PRIVATE_DATASETS';
    public const PURPOSE_READ_ONLY = 'READ_ONLY';
    public const PURPOSE_WORM_DROPBOX = 'WORM_DROPBOX';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPurposeAllowableValues()
    {
        return [
            self::PURPOSE_NO_PRESET,
            self::PURPOSE_DEFAULT_CLUSTER_SHARE,
            self::PURPOSE_DEFAULT_SHARE,
            self::PURPOSE_ENHANCED_TIMEMACHINE,
            self::PURPOSE_MULTI_PROTOCOL_NFS,
            self::PURPOSE_PRIVATE_DATASETS,
            self::PURPOSE_READ_ONLY,
            self::PURPOSE_WORM_DROPBOX,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('purpose', $data ?? [], 'DEFAULT_SHARE');
        $this->setIfExists('path', $data ?? [], null);
        $this->setIfExists('path_suffix', $data ?? [], '');
        $this->setIfExists('home', $data ?? [], false);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('comment', $data ?? [], '');
        $this->setIfExists('ro', $data ?? [], false);
        $this->setIfExists('browsable', $data ?? [], true);
        $this->setIfExists('timemachine', $data ?? [], false);
        $this->setIfExists('timemachine_quota', $data ?? [], 0);
        $this->setIfExists('recyclebin', $data ?? [], false);
        $this->setIfExists('guestok', $data ?? [], false);
        $this->setIfExists('abe', $data ?? [], false);
        $this->setIfExists('hostsallow', $data ?? [], null);
        $this->setIfExists('hostsdeny', $data ?? [], null);
        $this->setIfExists('aapl_name_mangling', $data ?? [], false);
        $this->setIfExists('acl', $data ?? [], true);
        $this->setIfExists('durablehandle', $data ?? [], true);
        $this->setIfExists('shadowcopy', $data ?? [], true);
        $this->setIfExists('streams', $data ?? [], true);
        $this->setIfExists('fsrvp', $data ?? [], false);
        $this->setIfExists('auxsmbconf', $data ?? [], '');
        $this->setIfExists('enabled', $data ?? [], true);
        $this->setIfExists('cluster_volname', $data ?? [], '');
        $this->setIfExists('afp', $data ?? [], false);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getPurposeAllowableValues();
        if (!is_null($this->container['purpose']) && !in_array($this->container['purpose'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'purpose', must be one of '%s'",
                $this->container['purpose'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets purpose
     *
     * @return string|null
     */
    public function getPurpose()
    {
        return $this->container['purpose'];
    }

    /**
     * Sets purpose
     *
     * @param string|null $purpose `purpose` applies common configuration presets depending on intended purpose.
     *
     * @return self
     */
    public function setPurpose($purpose)
    {
        $allowedValues = $this->getPurposeAllowableValues();
        if (!is_null($purpose) && !in_array($purpose, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'purpose', must be one of '%s'",
                    $purpose,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($purpose)) {
            throw new \InvalidArgumentException('non-nullable purpose cannot be null');
        }

        $this->container['purpose'] = $purpose;

        return $this;
    }

    /**
     * Gets path
     *
     * @return string|null
     */
    public function getPath()
    {
        return $this->container['path'];
    }

    /**
     * Sets path
     *
     * @param string|null $path `path` path to export over the SMB protocol. If server is clustered, then this path will be relative to the `cluster_volname`.
     *
     * @return self
     */
    public function setPath($path)
    {

        if (is_null($path)) {
            throw new \InvalidArgumentException('non-nullable path cannot be null');
        }

        $this->container['path'] = $path;

        return $this;
    }

    /**
     * Gets path_suffix
     *
     * @return string|null
     */
    public function getPathSuffix()
    {
        return $this->container['path_suffix'];
    }

    /**
     * Sets path_suffix
     *
     * @param string|null $path_suffix path_suffix
     *
     * @return self
     */
    public function setPathSuffix($path_suffix)
    {

        if (is_null($path_suffix)) {
            throw new \InvalidArgumentException('non-nullable path_suffix cannot be null');
        }

        $this->container['path_suffix'] = $path_suffix;

        return $this;
    }

    /**
     * Gets home
     *
     * @return bool|null
     */
    public function getHome()
    {
        return $this->container['home'];
    }

    /**
     * Sets home
     *
     * @param bool|null $home home
     *
     * @return self
     */
    public function setHome($home)
    {

        if (is_null($home)) {
            throw new \InvalidArgumentException('non-nullable home cannot be null');
        }

        $this->container['home'] = $home;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name name
     *
     * @return self
     */
    public function setName($name)
    {

        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets comment
     *
     * @return string|null
     */
    public function getComment()
    {
        return $this->container['comment'];
    }

    /**
     * Sets comment
     *
     * @param string|null $comment comment
     *
     * @return self
     */
    public function setComment($comment)
    {

        if (is_null($comment)) {
            throw new \InvalidArgumentException('non-nullable comment cannot be null');
        }

        $this->container['comment'] = $comment;

        return $this;
    }

    /**
     * Gets ro
     *
     * @return bool|null
     */
    public function getRo()
    {
        return $this->container['ro'];
    }

    /**
     * Sets ro
     *
     * @param bool|null $ro `ro` when enabled, prohibits write access to the share.
     *
     * @return self
     */
    public function setRo($ro)
    {

        if (is_null($ro)) {
            throw new \InvalidArgumentException('non-nullable ro cannot be null');
        }

        $this->container['ro'] = $ro;

        return $this;
    }

    /**
     * Gets browsable
     *
     * @return bool|null
     */
    public function getBrowsable()
    {
        return $this->container['browsable'];
    }

    /**
     * Sets browsable
     *
     * @param bool|null $browsable browsable
     *
     * @return self
     */
    public function setBrowsable($browsable)
    {

        if (is_null($browsable)) {
            throw new \InvalidArgumentException('non-nullable browsable cannot be null');
        }

        $this->container['browsable'] = $browsable;

        return $this;
    }

    /**
     * Gets timemachine
     *
     * @return bool|null
     */
    public function getTimemachine()
    {
        return $this->container['timemachine'];
    }

    /**
     * Sets timemachine
     *
     * @param bool|null $timemachine `timemachine` when set, enables Time Machine backups for this share.
     *
     * @return self
     */
    public function setTimemachine($timemachine)
    {

        if (is_null($timemachine)) {
            throw new \InvalidArgumentException('non-nullable timemachine cannot be null');
        }

        $this->container['timemachine'] = $timemachine;

        return $this;
    }

    /**
     * Gets timemachine_quota
     *
     * @return int|null
     */
    public function getTimemachineQuota()
    {
        return $this->container['timemachine_quota'];
    }

    /**
     * Sets timemachine_quota
     *
     * @param int|null $timemachine_quota timemachine_quota
     *
     * @return self
     */
    public function setTimemachineQuota($timemachine_quota)
    {

        if (is_null($timemachine_quota)) {
            throw new \InvalidArgumentException('non-nullable timemachine_quota cannot be null');
        }

        $this->container['timemachine_quota'] = $timemachine_quota;

        return $this;
    }

    /**
     * Gets recyclebin
     *
     * @return bool|null
     */
    public function getRecyclebin()
    {
        return $this->container['recyclebin'];
    }

    /**
     * Sets recyclebin
     *
     * @param bool|null $recyclebin recyclebin
     *
     * @return self
     */
    public function setRecyclebin($recyclebin)
    {

        if (is_null($recyclebin)) {
            throw new \InvalidArgumentException('non-nullable recyclebin cannot be null');
        }

        $this->container['recyclebin'] = $recyclebin;

        return $this;
    }

    /**
     * Gets guestok
     *
     * @return bool|null
     */
    public function getGuestok()
    {
        return $this->container['guestok'];
    }

    /**
     * Sets guestok
     *
     * @param bool|null $guestok `guestok` when enabled, allows access to this share without a password.
     *
     * @return self
     */
    public function setGuestok($guestok)
    {

        if (is_null($guestok)) {
            throw new \InvalidArgumentException('non-nullable guestok cannot be null');
        }

        $this->container['guestok'] = $guestok;

        return $this;
    }

    /**
     * Gets abe
     *
     * @return bool|null
     */
    public function getAbe()
    {
        return $this->container['abe'];
    }

    /**
     * Sets abe
     *
     * @param bool|null $abe abe
     *
     * @return self
     */
    public function setAbe($abe)
    {

        if (is_null($abe)) {
            throw new \InvalidArgumentException('non-nullable abe cannot be null');
        }

        $this->container['abe'] = $abe;

        return $this;
    }

    /**
     * Gets hostsallow
     *
     * @return mixed[]|null
     */
    public function getHostsallow()
    {
        return $this->container['hostsallow'];
    }

    /**
     * Sets hostsallow
     *
     * @param mixed[]|null $hostsallow `hostsallow` is a list of hostnames / IP addresses which have access to this share. `hostsdeny` is a list of hostnames / IP addresses which are not allowed access to this share. If a handful of hostnames are to be only allowed access, `hostsdeny` can be passed \"ALL\" which means that it will deny access to ALL hostnames except for the ones which have been listed in `hostsallow`.
     *
     * @return self
     */
    public function setHostsallow($hostsallow)
    {

        if (is_null($hostsallow)) {
            throw new \InvalidArgumentException('non-nullable hostsallow cannot be null');
        }

        $this->container['hostsallow'] = $hostsallow;

        return $this;
    }

    /**
     * Gets hostsdeny
     *
     * @return mixed[]|null
     */
    public function getHostsdeny()
    {
        return $this->container['hostsdeny'];
    }

    /**
     * Sets hostsdeny
     *
     * @param mixed[]|null $hostsdeny `hostsdeny` is a list of hostnames / IP addresses which are not allowed access to this share. If a handful of hostnames are to be only allowed access, `hostsdeny` can be passed \"ALL\" which means that it will deny access to ALL hostnames except for the ones which have been listed in `hostsallow`.
     *
     * @return self
     */
    public function setHostsdeny($hostsdeny)
    {

        if (is_null($hostsdeny)) {
            throw new \InvalidArgumentException('non-nullable hostsdeny cannot be null');
        }

        $this->container['hostsdeny'] = $hostsdeny;

        return $this;
    }

    /**
     * Gets aapl_name_mangling
     *
     * @return bool|null
     */
    public function getAaplNameMangling()
    {
        return $this->container['aapl_name_mangling'];
    }

    /**
     * Sets aapl_name_mangling
     *
     * @param bool|null $aapl_name_mangling aapl_name_mangling
     *
     * @return self
     */
    public function setAaplNameMangling($aapl_name_mangling)
    {

        if (is_null($aapl_name_mangling)) {
            throw new \InvalidArgumentException('non-nullable aapl_name_mangling cannot be null');
        }

        $this->container['aapl_name_mangling'] = $aapl_name_mangling;

        return $this;
    }

    /**
     * Gets acl
     *
     * @return bool|null
     */
    public function getAcl()
    {
        return $this->container['acl'];
    }

    /**
     * Sets acl
     *
     * @param bool|null $acl `acl` enables support for storing the SMB Security Descriptor as a Filesystem ACL.
     *
     * @return self
     */
    public function setAcl($acl)
    {

        if (is_null($acl)) {
            throw new \InvalidArgumentException('non-nullable acl cannot be null');
        }

        $this->container['acl'] = $acl;

        return $this;
    }

    /**
     * Gets durablehandle
     *
     * @return bool|null
     */
    public function getDurablehandle()
    {
        return $this->container['durablehandle'];
    }

    /**
     * Sets durablehandle
     *
     * @param bool|null $durablehandle durablehandle
     *
     * @return self
     */
    public function setDurablehandle($durablehandle)
    {

        if (is_null($durablehandle)) {
            throw new \InvalidArgumentException('non-nullable durablehandle cannot be null');
        }

        $this->container['durablehandle'] = $durablehandle;

        return $this;
    }

    /**
     * Gets shadowcopy
     *
     * @return bool|null
     */
    public function getShadowcopy()
    {
        return $this->container['shadowcopy'];
    }

    /**
     * Sets shadowcopy
     *
     * @param bool|null $shadowcopy `shadowcopy` enables support for the volume shadow copy service.
     *
     * @return self
     */
    public function setShadowcopy($shadowcopy)
    {

        if (is_null($shadowcopy)) {
            throw new \InvalidArgumentException('non-nullable shadowcopy cannot be null');
        }

        $this->container['shadowcopy'] = $shadowcopy;

        return $this;
    }

    /**
     * Gets streams
     *
     * @return bool|null
     */
    public function getStreams()
    {
        return $this->container['streams'];
    }

    /**
     * Sets streams
     *
     * @param bool|null $streams `streams` enables support for storing alternate datastreams as filesystem extended attributes.
     *
     * @return self
     */
    public function setStreams($streams)
    {

        if (is_null($streams)) {
            throw new \InvalidArgumentException('non-nullable streams cannot be null');
        }

        $this->container['streams'] = $streams;

        return $this;
    }

    /**
     * Gets fsrvp
     *
     * @return bool|null
     */
    public function getFsrvp()
    {
        return $this->container['fsrvp'];
    }

    /**
     * Sets fsrvp
     *
     * @param bool|null $fsrvp `fsrvp` enables support for the filesystem remote VSS protocol. This allows clients to create ZFS snapshots through RPC.
     *
     * @return self
     */
    public function setFsrvp($fsrvp)
    {

        if (is_null($fsrvp)) {
            throw new \InvalidArgumentException('non-nullable fsrvp cannot be null');
        }

        $this->container['fsrvp'] = $fsrvp;

        return $this;
    }

    /**
     * Gets auxsmbconf
     *
     * @return string|null
     */
    public function getAuxsmbconf()
    {
        return $this->container['auxsmbconf'];
    }

    /**
     * Sets auxsmbconf
     *
     * @param string|null $auxsmbconf auxsmbconf
     *
     * @return self
     */
    public function setAuxsmbconf($auxsmbconf)
    {

        if (is_null($auxsmbconf)) {
            throw new \InvalidArgumentException('non-nullable auxsmbconf cannot be null');
        }

        $this->container['auxsmbconf'] = $auxsmbconf;

        return $this;
    }

    /**
     * Gets enabled
     *
     * @return bool|null
     */
    public function getEnabled()
    {
        return $this->container['enabled'];
    }

    /**
     * Sets enabled
     *
     * @param bool|null $enabled enabled
     *
     * @return self
     */
    public function setEnabled($enabled)
    {

        if (is_null($enabled)) {
            throw new \InvalidArgumentException('non-nullable enabled cannot be null');
        }

        $this->container['enabled'] = $enabled;

        return $this;
    }

    /**
     * Gets cluster_volname
     *
     * @return string|null
     */
    public function getClusterVolname()
    {
        return $this->container['cluster_volname'];
    }

    /**
     * Sets cluster_volname
     *
     * @param string|null $cluster_volname `path` path to export over the SMB protocol. If server is clustered, then this path will be relative to the `cluster_volname`.
     *
     * @return self
     */
    public function setClusterVolname($cluster_volname)
    {

        if (is_null($cluster_volname)) {
            throw new \InvalidArgumentException('non-nullable cluster_volname cannot be null');
        }

        $this->container['cluster_volname'] = $cluster_volname;

        return $this;
    }

    /**
     * Gets afp
     *
     * @return bool|null
     */
    public function getAfp()
    {
        return $this->container['afp'];
    }

    /**
     * Sets afp
     *
     * @param bool|null $afp afp
     *
     * @return self
     */
    public function setAfp($afp)
    {

        if (is_null($afp)) {
            throw new \InvalidArgumentException('non-nullable afp cannot be null');
        }

        $this->container['afp'] = $afp;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


