<?php
/**
 * ActivedirectoryUpdate0
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TrueNAS RESTful API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace RMoore\Truenas\Model;

use \ArrayAccess;
use \RMoore\Truenas\ObjectSerializer;

/**
 * ActivedirectoryUpdate0 Class Doc Comment
 *
 * @category Class
 * @package  RMoore\Truenas
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ActivedirectoryUpdate0 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'activedirectory_update_0';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'domainname' => 'string',
        'bindname' => 'string',
        'bindpw' => 'string',
        'verbose_logging' => 'bool',
        'use_default_domain' => 'bool',
        'allow_trusted_doms' => 'bool',
        'allow_dns_updates' => 'bool',
        'disable_freenas_cache' => 'bool',
        'restrict_pam' => 'bool',
        'site' => 'string',
        'kerberos_realm' => 'int',
        'kerberos_principal' => 'string',
        'timeout' => 'int',
        'dns_timeout' => 'int',
        'nss_info' => 'string',
        'createcomputer' => 'string',
        'netbiosname' => 'string',
        'netbiosname_b' => 'string',
        'netbiosalias' => 'mixed[]',
        'enable' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'domainname' => null,
        'bindname' => null,
        'bindpw' => null,
        'verbose_logging' => null,
        'use_default_domain' => null,
        'allow_trusted_doms' => null,
        'allow_dns_updates' => null,
        'disable_freenas_cache' => null,
        'restrict_pam' => null,
        'site' => null,
        'kerberos_realm' => null,
        'kerberos_principal' => null,
        'timeout' => null,
        'dns_timeout' => null,
        'nss_info' => null,
        'createcomputer' => null,
        'netbiosname' => null,
        'netbiosname_b' => null,
        'netbiosalias' => null,
        'enable' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'domainname' => false,
		'bindname' => false,
		'bindpw' => false,
		'verbose_logging' => false,
		'use_default_domain' => false,
		'allow_trusted_doms' => false,
		'allow_dns_updates' => false,
		'disable_freenas_cache' => false,
		'restrict_pam' => false,
		'site' => true,
		'kerberos_realm' => true,
		'kerberos_principal' => true,
		'timeout' => false,
		'dns_timeout' => false,
		'nss_info' => true,
		'createcomputer' => false,
		'netbiosname' => false,
		'netbiosname_b' => false,
		'netbiosalias' => false,
		'enable' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'domainname' => 'domainname',
        'bindname' => 'bindname',
        'bindpw' => 'bindpw',
        'verbose_logging' => 'verbose_logging',
        'use_default_domain' => 'use_default_domain',
        'allow_trusted_doms' => 'allow_trusted_doms',
        'allow_dns_updates' => 'allow_dns_updates',
        'disable_freenas_cache' => 'disable_freenas_cache',
        'restrict_pam' => 'restrict_pam',
        'site' => 'site',
        'kerberos_realm' => 'kerberos_realm',
        'kerberos_principal' => 'kerberos_principal',
        'timeout' => 'timeout',
        'dns_timeout' => 'dns_timeout',
        'nss_info' => 'nss_info',
        'createcomputer' => 'createcomputer',
        'netbiosname' => 'netbiosname',
        'netbiosname_b' => 'netbiosname_b',
        'netbiosalias' => 'netbiosalias',
        'enable' => 'enable'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'domainname' => 'setDomainname',
        'bindname' => 'setBindname',
        'bindpw' => 'setBindpw',
        'verbose_logging' => 'setVerboseLogging',
        'use_default_domain' => 'setUseDefaultDomain',
        'allow_trusted_doms' => 'setAllowTrustedDoms',
        'allow_dns_updates' => 'setAllowDnsUpdates',
        'disable_freenas_cache' => 'setDisableFreenasCache',
        'restrict_pam' => 'setRestrictPam',
        'site' => 'setSite',
        'kerberos_realm' => 'setKerberosRealm',
        'kerberos_principal' => 'setKerberosPrincipal',
        'timeout' => 'setTimeout',
        'dns_timeout' => 'setDnsTimeout',
        'nss_info' => 'setNssInfo',
        'createcomputer' => 'setCreatecomputer',
        'netbiosname' => 'setNetbiosname',
        'netbiosname_b' => 'setNetbiosnameB',
        'netbiosalias' => 'setNetbiosalias',
        'enable' => 'setEnable'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'domainname' => 'getDomainname',
        'bindname' => 'getBindname',
        'bindpw' => 'getBindpw',
        'verbose_logging' => 'getVerboseLogging',
        'use_default_domain' => 'getUseDefaultDomain',
        'allow_trusted_doms' => 'getAllowTrustedDoms',
        'allow_dns_updates' => 'getAllowDnsUpdates',
        'disable_freenas_cache' => 'getDisableFreenasCache',
        'restrict_pam' => 'getRestrictPam',
        'site' => 'getSite',
        'kerberos_realm' => 'getKerberosRealm',
        'kerberos_principal' => 'getKerberosPrincipal',
        'timeout' => 'getTimeout',
        'dns_timeout' => 'getDnsTimeout',
        'nss_info' => 'getNssInfo',
        'createcomputer' => 'getCreatecomputer',
        'netbiosname' => 'getNetbiosname',
        'netbiosname_b' => 'getNetbiosnameB',
        'netbiosalias' => 'getNetbiosalias',
        'enable' => 'getEnable'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const NSS_INFO_SFU = 'SFU';
    public const NSS_INFO_SFU20 = 'SFU20';
    public const NSS_INFO_RFC2307 = 'RFC2307';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getNssInfoAllowableValues()
    {
        return [
            self::NSS_INFO_SFU,
            self::NSS_INFO_SFU20,
            self::NSS_INFO_RFC2307,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('domainname', $data ?? [], null);
        $this->setIfExists('bindname', $data ?? [], null);
        $this->setIfExists('bindpw', $data ?? [], null);
        $this->setIfExists('verbose_logging', $data ?? [], null);
        $this->setIfExists('use_default_domain', $data ?? [], null);
        $this->setIfExists('allow_trusted_doms', $data ?? [], null);
        $this->setIfExists('allow_dns_updates', $data ?? [], null);
        $this->setIfExists('disable_freenas_cache', $data ?? [], null);
        $this->setIfExists('restrict_pam', $data ?? [], false);
        $this->setIfExists('site', $data ?? [], null);
        $this->setIfExists('kerberos_realm', $data ?? [], null);
        $this->setIfExists('kerberos_principal', $data ?? [], null);
        $this->setIfExists('timeout', $data ?? [], 60);
        $this->setIfExists('dns_timeout', $data ?? [], 10);
        $this->setIfExists('nss_info', $data ?? [], '');
        $this->setIfExists('createcomputer', $data ?? [], null);
        $this->setIfExists('netbiosname', $data ?? [], null);
        $this->setIfExists('netbiosname_b', $data ?? [], null);
        $this->setIfExists('netbiosalias', $data ?? [], null);
        $this->setIfExists('enable', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getNssInfoAllowableValues();
        if (!is_null($this->container['nss_info']) && !in_array($this->container['nss_info'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'nss_info', must be one of '%s'",
                $this->container['nss_info'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets domainname
     *
     * @return string|null
     */
    public function getDomainname()
    {
        return $this->container['domainname'];
    }

    /**
     * Sets domainname
     *
     * @param string|null $domainname `domainname` full DNS domain name of the Active Directory domain.
     *
     * @return self
     */
    public function setDomainname($domainname)
    {

        if (is_null($domainname)) {
            throw new \InvalidArgumentException('non-nullable domainname cannot be null');
        }

        $this->container['domainname'] = $domainname;

        return $this;
    }

    /**
     * Gets bindname
     *
     * @return string|null
     */
    public function getBindname()
    {
        return $this->container['bindname'];
    }

    /**
     * Sets bindname
     *
     * @param string|null $bindname `bindname` username used to perform the intial domain join.
     *
     * @return self
     */
    public function setBindname($bindname)
    {

        if (is_null($bindname)) {
            throw new \InvalidArgumentException('non-nullable bindname cannot be null');
        }

        $this->container['bindname'] = $bindname;

        return $this;
    }

    /**
     * Gets bindpw
     *
     * @return string|null
     */
    public function getBindpw()
    {
        return $this->container['bindpw'];
    }

    /**
     * Sets bindpw
     *
     * @param string|null $bindpw `bindpw` password used to perform the initial domain join. User- provided credentials are used to obtain a kerberos ticket, which is used to perform the actual domain join.
     *
     * @return self
     */
    public function setBindpw($bindpw)
    {

        if (is_null($bindpw)) {
            throw new \InvalidArgumentException('non-nullable bindpw cannot be null');
        }

        $this->container['bindpw'] = $bindpw;

        return $this;
    }

    /**
     * Gets verbose_logging
     *
     * @return bool|null
     */
    public function getVerboseLogging()
    {
        return $this->container['verbose_logging'];
    }

    /**
     * Sets verbose_logging
     *
     * @param bool|null $verbose_logging `verbose_logging` increase logging during the domain join process.
     *
     * @return self
     */
    public function setVerboseLogging($verbose_logging)
    {

        if (is_null($verbose_logging)) {
            throw new \InvalidArgumentException('non-nullable verbose_logging cannot be null');
        }

        $this->container['verbose_logging'] = $verbose_logging;

        return $this;
    }

    /**
     * Gets use_default_domain
     *
     * @return bool|null
     */
    public function getUseDefaultDomain()
    {
        return $this->container['use_default_domain'];
    }

    /**
     * Sets use_default_domain
     *
     * @param bool|null $use_default_domain `use_default_domain` controls whether domain users and groups have the pre-windows 2000 domain name prepended to the user account. When enabled, the user appears as \"administrator\" rather than \"EXAMPLEdministrator\"
     *
     * @return self
     */
    public function setUseDefaultDomain($use_default_domain)
    {

        if (is_null($use_default_domain)) {
            throw new \InvalidArgumentException('non-nullable use_default_domain cannot be null');
        }

        $this->container['use_default_domain'] = $use_default_domain;

        return $this;
    }

    /**
     * Gets allow_trusted_doms
     *
     * @return bool|null
     */
    public function getAllowTrustedDoms()
    {
        return $this->container['allow_trusted_doms'];
    }

    /**
     * Sets allow_trusted_doms
     *
     * @param bool|null $allow_trusted_doms `allow_trusted_doms` enable support for trusted domains. If this parameter is enabled, then separate idmap backends _must_ be configured for each trusted domain, and the idmap cache should be cleared.
     *
     * @return self
     */
    public function setAllowTrustedDoms($allow_trusted_doms)
    {

        if (is_null($allow_trusted_doms)) {
            throw new \InvalidArgumentException('non-nullable allow_trusted_doms cannot be null');
        }

        $this->container['allow_trusted_doms'] = $allow_trusted_doms;

        return $this;
    }

    /**
     * Gets allow_dns_updates
     *
     * @return bool|null
     */
    public function getAllowDnsUpdates()
    {
        return $this->container['allow_dns_updates'];
    }

    /**
     * Sets allow_dns_updates
     *
     * @param bool|null $allow_dns_updates `allow_dns_updates` during the domain join process, automatically generate DNS entries in the AD domain for the NAS. If this is disabled, then a domain administrator must manually add appropriate DNS entries for the NAS. This parameter is recommended for TrueNAS HA servers.
     *
     * @return self
     */
    public function setAllowDnsUpdates($allow_dns_updates)
    {

        if (is_null($allow_dns_updates)) {
            throw new \InvalidArgumentException('non-nullable allow_dns_updates cannot be null');
        }

        $this->container['allow_dns_updates'] = $allow_dns_updates;

        return $this;
    }

    /**
     * Gets disable_freenas_cache
     *
     * @return bool|null
     */
    public function getDisableFreenasCache()
    {
        return $this->container['disable_freenas_cache'];
    }

    /**
     * Sets disable_freenas_cache
     *
     * @param bool|null $disable_freenas_cache `disable_freenas_cache` disables active caching of AD users and groups. When disabled, only users cached in winbind's internal cache are visible in GUI dropdowns. Disabling active caching is recommended in environments with a large amount of users.
     *
     * @return self
     */
    public function setDisableFreenasCache($disable_freenas_cache)
    {

        if (is_null($disable_freenas_cache)) {
            throw new \InvalidArgumentException('non-nullable disable_freenas_cache cannot be null');
        }

        $this->container['disable_freenas_cache'] = $disable_freenas_cache;

        return $this;
    }

    /**
     * Gets restrict_pam
     *
     * @return bool|null
     */
    public function getRestrictPam()
    {
        return $this->container['restrict_pam'];
    }

    /**
     * Sets restrict_pam
     *
     * @param bool|null $restrict_pam restrict_pam
     *
     * @return self
     */
    public function setRestrictPam($restrict_pam)
    {

        if (is_null($restrict_pam)) {
            throw new \InvalidArgumentException('non-nullable restrict_pam cannot be null');
        }

        $this->container['restrict_pam'] = $restrict_pam;

        return $this;
    }

    /**
     * Gets site
     *
     * @return string|null
     */
    public function getSite()
    {
        return $this->container['site'];
    }

    /**
     * Sets site
     *
     * @param string|null $site `site` AD site of which the NAS is a member. This parameter is auto- detected during the domain join process. If no AD site is configured for the subnet in which the NAS is configured, then this parameter appears as 'Default-First-Site-Name'. Auto-detection is only performed during the initial domain join.
     *
     * @return self
     */
    public function setSite($site)
    {

        if (is_null($site)) {
            array_push($this->openAPINullablesSetToNull, 'site');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('site', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['site'] = $site;

        return $this;
    }

    /**
     * Gets kerberos_realm
     *
     * @return int|null
     */
    public function getKerberosRealm()
    {
        return $this->container['kerberos_realm'];
    }

    /**
     * Sets kerberos_realm
     *
     * @param int|null $kerberos_realm `kerberos_realm` in which the server is located. This parameter is automatically populated during the initial domain join. If the NAS has an AD site configured and that site has multiple kerberos servers, then the kerberos realm is automatically updated with a site-specific configuration to use those servers. Auto-detection is only performed during initial domain join.
     *
     * @return self
     */
    public function setKerberosRealm($kerberos_realm)
    {

        if (is_null($kerberos_realm)) {
            array_push($this->openAPINullablesSetToNull, 'kerberos_realm');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('kerberos_realm', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['kerberos_realm'] = $kerberos_realm;

        return $this;
    }

    /**
     * Gets kerberos_principal
     *
     * @return string|null
     */
    public function getKerberosPrincipal()
    {
        return $this->container['kerberos_principal'];
    }

    /**
     * Sets kerberos_principal
     *
     * @param string|null $kerberos_principal `kerberos_principal` kerberos principal to use for AD-related operations outside of Samba. After intial domain join, this field is updated with the kerberos principal associated with the AD machine account for the NAS.
     *
     * @return self
     */
    public function setKerberosPrincipal($kerberos_principal)
    {

        if (is_null($kerberos_principal)) {
            array_push($this->openAPINullablesSetToNull, 'kerberos_principal');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('kerberos_principal', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['kerberos_principal'] = $kerberos_principal;

        return $this;
    }

    /**
     * Gets timeout
     *
     * @return int|null
     */
    public function getTimeout()
    {
        return $this->container['timeout'];
    }

    /**
     * Sets timeout
     *
     * @param int|null $timeout `timeout` timeout value for winbind-related operations. This value may need to be increased in  environments with high latencies for communications with domain controllers or a large number of domain controllers. Lowering the value may cause status checks to fail.
     *
     * @return self
     */
    public function setTimeout($timeout)
    {

        if (is_null($timeout)) {
            throw new \InvalidArgumentException('non-nullable timeout cannot be null');
        }

        $this->container['timeout'] = $timeout;

        return $this;
    }

    /**
     * Gets dns_timeout
     *
     * @return int|null
     */
    public function getDnsTimeout()
    {
        return $this->container['dns_timeout'];
    }

    /**
     * Sets dns_timeout
     *
     * @param int|null $dns_timeout `dns_timeout` timeout value for DNS queries during the initial domain join. This value is also set as the NETWORK_TIMEOUT in the ldap config file.
     *
     * @return self
     */
    public function setDnsTimeout($dns_timeout)
    {

        if (is_null($dns_timeout)) {
            throw new \InvalidArgumentException('non-nullable dns_timeout cannot be null');
        }

        $this->container['dns_timeout'] = $dns_timeout;

        return $this;
    }

    /**
     * Gets nss_info
     *
     * @return string|null
     */
    public function getNssInfo()
    {
        return $this->container['nss_info'];
    }

    /**
     * Sets nss_info
     *
     * @param string|null $nss_info `nss_info` controls how Winbind retrieves Name Service Information to construct a user's home directory and login shell. This parameter is only effective if the Active Directory Domain Controller supports the Microsoft Services for Unix (SFU) LDAP schema.
     *
     * @return self
     */
    public function setNssInfo($nss_info)
    {
        $allowedValues = $this->getNssInfoAllowableValues();
        if (!is_null($nss_info) && !in_array($nss_info, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'nss_info', must be one of '%s'",
                    $nss_info,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($nss_info)) {
            array_push($this->openAPINullablesSetToNull, 'nss_info');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('nss_info', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['nss_info'] = $nss_info;

        return $this;
    }

    /**
     * Gets createcomputer
     *
     * @return string|null
     */
    public function getCreatecomputer()
    {
        return $this->container['createcomputer'];
    }

    /**
     * Sets createcomputer
     *
     * @param string|null $createcomputer `createcomputer` Active Directory Organizational Unit in which new computer accounts are created.
     *
     * @return self
     */
    public function setCreatecomputer($createcomputer)
    {

        if (is_null($createcomputer)) {
            throw new \InvalidArgumentException('non-nullable createcomputer cannot be null');
        }

        $this->container['createcomputer'] = $createcomputer;

        return $this;
    }

    /**
     * Gets netbiosname
     *
     * @return string|null
     */
    public function getNetbiosname()
    {
        return $this->container['netbiosname'];
    }

    /**
     * Sets netbiosname
     *
     * @param string|null $netbiosname netbiosname
     *
     * @return self
     */
    public function setNetbiosname($netbiosname)
    {

        if (is_null($netbiosname)) {
            throw new \InvalidArgumentException('non-nullable netbiosname cannot be null');
        }

        $this->container['netbiosname'] = $netbiosname;

        return $this;
    }

    /**
     * Gets netbiosname_b
     *
     * @return string|null
     */
    public function getNetbiosnameB()
    {
        return $this->container['netbiosname_b'];
    }

    /**
     * Sets netbiosname_b
     *
     * @param string|null $netbiosname_b netbiosname_b
     *
     * @return self
     */
    public function setNetbiosnameB($netbiosname_b)
    {

        if (is_null($netbiosname_b)) {
            throw new \InvalidArgumentException('non-nullable netbiosname_b cannot be null');
        }

        $this->container['netbiosname_b'] = $netbiosname_b;

        return $this;
    }

    /**
     * Gets netbiosalias
     *
     * @return mixed[]|null
     */
    public function getNetbiosalias()
    {
        return $this->container['netbiosalias'];
    }

    /**
     * Sets netbiosalias
     *
     * @param mixed[]|null $netbiosalias netbiosalias
     *
     * @return self
     */
    public function setNetbiosalias($netbiosalias)
    {

        if (is_null($netbiosalias)) {
            throw new \InvalidArgumentException('non-nullable netbiosalias cannot be null');
        }

        $this->container['netbiosalias'] = $netbiosalias;

        return $this;
    }

    /**
     * Gets enable
     *
     * @return bool|null
     */
    public function getEnable()
    {
        return $this->container['enable'];
    }

    /**
     * Sets enable
     *
     * @param bool|null $enable The Active Directory service is started after a configuration update if the service was initially disabled, and the updated configuration sets `enable` to `True`. The Active Directory service is stopped if `enable` is changed to `False`. If the configuration is updated, but the initial `enable` state is `True`, and remains unchanged, then the samba server is only restarted.
     *
     * @return self
     */
    public function setEnable($enable)
    {

        if (is_null($enable)) {
            throw new \InvalidArgumentException('non-nullable enable cannot be null');
        }

        $this->container['enable'] = $enable;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


